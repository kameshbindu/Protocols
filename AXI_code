# Protocols
All Protocols Codes
interface axi_if;

//write address channel 

logic              AWREADY;  // ready signal for write address which is initiated by the slave
logic              AWVALID;  // valid signal for write address which is initiated by the master
logic     [1:0]    AWBURST;  // Burst signal is sent according to the type of the burst
logic     [2:0]    AWSIZE;   // this signal indicates the size of the burst
logic     [3:0]    AWLEN;    // this signal indicates the lenght of the burst
logic     [31:0]   AWADDR;   //  this signal sent by the master for the selection purpose of the slave with a particular address
logic     [3:0]    AWID;     // for every slave there must be a seperate slave to select on which id the address is going to take

//write data channel

logic        [31:0]  WDATA   // for writing the data this channel is used
logic        [3:0]   WID     // for every slave there must be a slave
logic                WVALID  // it is used by the master to initiate the valid data to the slave
logic                WREADY  // whenever slave is ready to take data from the master this signal must be active for handshake
logic        [3:0]   WSTRB   // this signal indicates the valid data byte.
logic                WLAST   // this is the signal to indicate the last sequence_item of the transfer

//read address channel

logic                 ARREADY;  // for reading the data from slave here this signal must be active
logic                 ARVALID;  // valid singal is generated by the master 
logic         [1:0]   ARBURST;  // depending on this signal input the type of burst is decieded
logic         [2:0]   ARSIZE;   // size of the burst indication signal
logic         [3:0]   ARLEN;    // length of burst is indicated by this signal
logic         [31:0]  ARADDR;   // slave's address is made by this signal 
logic         [3:0]   ARID;     // id'of different slaves are selected by this signal

//read data channel

logic                  RLAST     // this signal indicates the last sequence_item of the read operation
logic                  RVALID    // this signal is used by the master for read operation from the slave
logic                  RREADY    // this signal is used by the slave to make read operation by the master
logic          [1:0]   RRESP     // this is the signal to indicate what type of read operation is done
logic          [31:0]  RDATA     // this is the signal to indicate the data bits
logic          [3:0]   RID      //  this is the signal to indicate on which slave the read operation will be done


//write response channel

logic        [1:0]   BRESP     // write response is the signal to indicate type of write operation is done(okay,exokay,slverr,decerr)
logic        [3:0]   BWID      // id of a particular slave is slected based on this signal
logic                BVALID    // signal which is generated by the slave
logic                BREADY    // when ever this signal is active to indicate master is ready to take response


 clocking m_drv_cb @(posedge clk);
        output AWID, AWADDR, AWLEN, AWSIZE, AWBURST,AWVALID, WID, WDATA, WSTRB, WLAST, WVALID, 
                BREADY, ARID, ARADDR, ARLEN, ARSIZE, ARBURST, ARVALID, RREADY;
        input AWREADY, WREADY, BID, BRESP, BVALID, ARREADY, RID, RDATA, RRESP, RLAST, RVALID;
    endclocking

   clocking m_mon_cb @(posedge clk);
        input AWID, AWADDR, AWLEN, AWSIZE, AWBURST,AWVALID, WID, WDATA, WSTRB, WLAST, WVALID, 
                BREADY, ARID, ARADDR, ARLEN, ARSIZE, ARBURST, ARVALID, RREADY;
        input AWREADY, WREADY, BID, BRESP, BVALID, ARREADY, RID, RDATA, RRESP, RLAST, RVALID;
    endclocking

    clocking s_mon_cb @(posedge clk);
        input AWID, AWADDR, AWLEN, AWSIZE, AWBURST,AWVALID, WID, WDATA, WSTRB, WLAST, WVALID, 
                BREADY, ARID, ARADDR, ARLEN, ARSIZE, ARBURST, ARVALID, RREADY;
        input AWREADY, WREADY, BID, BRESP, BVALID, ARREADY, RID, RDATA, RRESP, RLAST, RVALID;
    endclocking

    clocking s_drv_cb @(posedge clk);
        input AWID, AWADDR, AWLEN, AWSIZE, AWBURST,AWVALID, WID, WDATA, WSTRB, WLAST, WVALID, 
                BREADY, ARID, ARADDR, ARLEN, ARSIZE, ARBURST, ARVALID, RREADY;
         output AWREADY, WREADY, BID, BRESP, BVALID, ARREADY, RID, RDATA, RRESP, RLAST, RVALID;
    endclocking

    modport MDRV(clocking m_drv_cb, input rstn);
    modport MMON(clocking m_mon_cb, input rstn);
    modport SDRV(clocking s_drv_cb, input rstn);
    modport SMON(clocking s_mon_cb, input rstn);

    //after the aw_valid signal is asserted all the signal must be stable
      property aw_valid;
        @(posedge clk) $rose(AWVALID) |-> ( $stable(AWID)   
                                            &&$stable(AWADDR)
                                            &&$stable(AWLEN)
                                            &&$stable(AWSIZE) 
                                            &&$stable(AWBURST)) throughout AWREADY[->1];
    endproperty

    // after AWVALID is asserted all the signal must be stable
    property w_valid;
        @(posedge clk) $rose(WVALID) |-> (  $stable(WID)                                   
                                            && $stable(WDATA)
                                            && $stable(WSTRB)
                                            && $stable(WLAST)) throughout WREADY[->1];
    endproperty



    // after AWVALID is asserted all the signal must be stable
    property b_valid;
        @(posedge clk) $rose(BVALID) |-> (  $stable(BID) 
                                            && $stable(BRESP)) throughout BREADY[->1];
    endproperty

    //  after AWVALID is asserted all the signals must be stable
    property aw_valid;
        @(posedge clk) $rose(ARVALID) |-> ( $stable(ARID)   
                                            &&$stable(ARADDR)
                                            &&$stable(ARLEN)
                                            &&$stable(ARSIZE) 
                                            &&$stable(ARBURST)) throughout ARREADY[->1];
    endproperty

    // after RValid all the signal must be stabe
     property r_vaild;
        @(posedge clk) $rose(RVALID) |-> (  $stable(RID) 
                                            && $stable(RDATA)
                                            && $stable(RRESP)
                                            && $stable(RLAST)) throughout RREADY[->1];
    endproperty

    assert property (aw_valid);
    assert property (w_valid);
    assert property (b_valid);
    assert property (ar_valid);
    assert property (r_valid);


endinterface
